// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: customers.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (
  "tenant_id",
  "customer_id",
  "customer_name" ,
  "customer_address",
  "customer_city" ,
  "customer_state" ,
  "customer_country" ,
  "customer_total_value" ,
  "customer_status",
  "customer_app_type" ,
  "customer_reference" ,
  "customer_app_size" ,
  "customer_primary_email" ,
  "customer_primary_phone" ,
  "customer_secondary_email" ,
  "customer_secondary_phone" 
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9 , $10, $11, $12, $13, $14, $15, $16
) RETURNING customer_uuid, tenant_id, customer_id, customer_name, customer_address, customer_city, customer_state, customer_country, customer_total_value, customer_status, customer_app_type, customer_reference, customer_app_size, customer_primary_email, customer_primary_phone, customer_secondary_email, customer_secondary_phone
`

type CreateCustomerParams struct {
	TenantID               string `json:"tenant_id"`
	CustomerID             string `json:"customer_id"`
	CustomerName           string `json:"customer_name"`
	CustomerAddress        string `json:"customer_address"`
	CustomerCity           string `json:"customer_city"`
	CustomerState          string `json:"customer_state"`
	CustomerCountry        string `json:"customer_country"`
	CustomerTotalValue     int64  `json:"customer_total_value"`
	CustomerStatus         string `json:"customer_status"`
	CustomerAppType        string `json:"customer_app_type"`
	CustomerReference      string `json:"customer_reference"`
	CustomerAppSize        string `json:"customer_app_size"`
	CustomerPrimaryEmail   string `json:"customer_primary_email"`
	CustomerPrimaryPhone   string `json:"customer_primary_phone"`
	CustomerSecondaryEmail string `json:"customer_secondary_email"`
	CustomerSecondaryPhone string `json:"customer_secondary_phone"`
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.queryRow(ctx, q.createCustomerStmt, createCustomer,
		arg.TenantID,
		arg.CustomerID,
		arg.CustomerName,
		arg.CustomerAddress,
		arg.CustomerCity,
		arg.CustomerState,
		arg.CustomerCountry,
		arg.CustomerTotalValue,
		arg.CustomerStatus,
		arg.CustomerAppType,
		arg.CustomerReference,
		arg.CustomerAppSize,
		arg.CustomerPrimaryEmail,
		arg.CustomerPrimaryPhone,
		arg.CustomerSecondaryEmail,
		arg.CustomerSecondaryPhone,
	)
	var i Customer
	err := row.Scan(
		&i.CustomerUuid,
		&i.TenantID,
		&i.CustomerID,
		&i.CustomerName,
		&i.CustomerAddress,
		&i.CustomerCity,
		&i.CustomerState,
		&i.CustomerCountry,
		&i.CustomerTotalValue,
		&i.CustomerStatus,
		&i.CustomerAppType,
		&i.CustomerReference,
		&i.CustomerAppSize,
		&i.CustomerPrimaryEmail,
		&i.CustomerPrimaryPhone,
		&i.CustomerSecondaryEmail,
		&i.CustomerSecondaryPhone,
	)
	return i, err
}

const deleteCustomerByID = `-- name: DeleteCustomerByID :exec
delete from customers
where tenant_id = $1 and customer_uuid = $2
`

type DeleteCustomerByIDParams struct {
	TenantID     string    `json:"tenant_id"`
	CustomerUuid uuid.UUID `json:"customer_uuid"`
}

func (q *Queries) DeleteCustomerByID(ctx context.Context, arg DeleteCustomerByIDParams) error {
	_, err := q.exec(ctx, q.deleteCustomerByIDStmt, deleteCustomerByID, arg.TenantID, arg.CustomerUuid)
	return err
}

const listCustomerByID = `-- name: ListCustomerByID :one
select customer_uuid, tenant_id, customer_id, customer_name, customer_address, customer_city, customer_state, customer_country, customer_total_value, customer_status, customer_app_type, customer_reference, customer_app_size, customer_primary_email, customer_primary_phone, customer_secondary_email, customer_secondary_phone
from customers
where tenant_id = $1 AND customer_uuid = $2
`

type ListCustomerByIDParams struct {
	TenantID     string    `json:"tenant_id"`
	CustomerUuid uuid.UUID `json:"customer_uuid"`
}

func (q *Queries) ListCustomerByID(ctx context.Context, arg ListCustomerByIDParams) (Customer, error) {
	row := q.queryRow(ctx, q.listCustomerByIDStmt, listCustomerByID, arg.TenantID, arg.CustomerUuid)
	var i Customer
	err := row.Scan(
		&i.CustomerUuid,
		&i.TenantID,
		&i.CustomerID,
		&i.CustomerName,
		&i.CustomerAddress,
		&i.CustomerCity,
		&i.CustomerState,
		&i.CustomerCountry,
		&i.CustomerTotalValue,
		&i.CustomerStatus,
		&i.CustomerAppType,
		&i.CustomerReference,
		&i.CustomerAppSize,
		&i.CustomerPrimaryEmail,
		&i.CustomerPrimaryPhone,
		&i.CustomerSecondaryEmail,
		&i.CustomerSecondaryPhone,
	)
	return i, err
}

const listCustomers = `-- name: ListCustomers :many
select customer_uuid, tenant_id, customer_id, customer_name, customer_address, customer_city, customer_state, customer_country, customer_total_value, customer_status, customer_app_type, customer_reference, customer_app_size, customer_primary_email, customer_primary_phone, customer_secondary_email, customer_secondary_phone from customers
where tenant_id = $1
LIMIT $2
OFFSET $3
`

type ListCustomersParams struct {
	TenantID string `json:"tenant_id"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) ListCustomers(ctx context.Context, arg ListCustomersParams) ([]Customer, error) {
	rows, err := q.query(ctx, q.listCustomersStmt, listCustomers, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Customer{}
	for rows.Next() {
		var i Customer
		if err := rows.Scan(
			&i.CustomerUuid,
			&i.TenantID,
			&i.CustomerID,
			&i.CustomerName,
			&i.CustomerAddress,
			&i.CustomerCity,
			&i.CustomerState,
			&i.CustomerCountry,
			&i.CustomerTotalValue,
			&i.CustomerStatus,
			&i.CustomerAppType,
			&i.CustomerReference,
			&i.CustomerAppSize,
			&i.CustomerPrimaryEmail,
			&i.CustomerPrimaryPhone,
			&i.CustomerSecondaryEmail,
			&i.CustomerSecondaryPhone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
